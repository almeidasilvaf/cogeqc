
#' Calculate homogeneity scores for orthogroups
#'
#' @param orthogroup_df Data frame with orthogroups and their associated genes
#' and annotation. The columns \strong{Gene}, \strong{Orthogroup}, and
#' \strong{Annotation} are mandatory, and they must represent Gene ID,
#' Orthogroup ID, and Annotation ID (e.g., Interpro/PFAM), respectively.
#' @param correct_overclustering Logical indicating whether to correct
#' for overclustering in orthogroups. Default: TRUE.
#' @param weight_homogeneity Numeric indicating the weight to which homogeneity
#' scores will be multiplied. Only valid
#' if \strong{correct_overclustering = TRUE}. Default: 1.
#' @param weight_dispersal Numeric indicating the weight to which dispersal
#' scores will be multiplied. Only valid
#' if \strong{correct_overclustering = TRUE}. Default: 1.
#' @param scale Logical indicating whether or not to scale scores by the
#' maximum value. Only valid if \strong{correct_overclustering = TRUE}.
#' Default: TRUE.
#'
#' @details
#' Homogeneity is calculated based on pairwise Sorensen-Dice similarity
#' indices between gene pairs in an orthogroup, and they range
#' from 0 to 1. Thus, if all genes in an
#' orthogroup share the same domain, the orthogroup will have a homogeneity
#' score of 1. On the other hand, if genes in an orthogroup do not have any
#' domain in common, the orthogroup will have a homogeneity score of 0.
#' Additionally, users can correct for overclustering by penalizing
#' protein domains that appear in multiple orthogroups (default).
#'
#' @return A 2-column data frame with the variables \strong{Orthogroup}
#' and \strong{Score}, corresponding to orthogroup ID and orthogroup score,
#' respectively.
#' @export
#' @rdname calculate_H
#' @examples
#' data(og)
#' data(interpro_ath)
#' orthogroup_df <- merge(og[og$Species == "Ath", ], interpro_ath)
#' # Filter data to reduce run time
#' orthogroup_df <- orthogroup_df[1:10000, ]
#' H <- calculate_H(orthogroup_df, weight_homogeneity = 1, weight_dispersal = 1)
calculate_H <- function(orthogroup_df, correct_overclustering = TRUE,
                        weight_homogeneity = 1, weight_dispersal = 1,
                        scale = TRUE) {

    by_og <- split(orthogroup_df, orthogroup_df$Orthogroup)

    # Calculate homogeneity scores
    sdice <- Reduce(rbind, lapply(by_og, function(x) {
        genes <- unique(x$Gene)
        og <- unique(x$Orthogroup)

        scores_df <- NULL
        if(length(genes) > 1) {
            # Create a list of domains for each gene
            domains_per_gene <- split(x$Annotation, x$Gene)

            # Calculate Sorensen-Dice indices for all pairwise combinations
            combinations <- utils::combn(genes, 2, simplify = FALSE)
            scores <- lapply(combinations, function(y) {
                d1 <- x$Annotation[x$Gene == y[1]]
                d2 <- x$Annotation[x$Gene == y[2]]

                numerator <- 2 * length(intersect(d1, d2))
                denominator <- length(d1) + length(d2)
                s <- round(numerator / denominator, 2)
                return(s)
            })
            scores <- mean(Reduce(c, scores))

            scores_df <- data.frame(
                Orthogroup = og,
                Score = scores
            )
        }
        return(scores_df)
    }))

    # Account for overclustering
    if(correct_overclustering) {
        n_ortho <- length(unique(orthogroup_df$Orthogroup))

        dispersal <- split(orthogroup_df, orthogroup_df$Annotation)
        dispersal <- unlist(lapply(dispersal, function(x) {
            return(length(unique(x$Orthogroup)))
        }))
        scaled_dispersal <- sum(dispersal) / n_ortho # normalize to OG number

        sdice$Score <- (weight_homogeneity * sdice$Score) /
            (weight_dispersal * scaled_dispersal)
        if(scale) { # scale to the maximum value?
            sdice$Score <- sdice$Score / max(sdice$Score)
        }
    }
    return(sdice)
}



#' Assess orthogroup inference based on functional annotation
#'
#'
#' @param orthogroups A 3-column data frame with columns \strong{Orthogroup},
#' \strong{Species}, and \strong{Gene}. This data frame can be created from
#' the 'Orthogroups.tsv' file generated by OrthoFinder with the function
#' \code{read_orthogroups()}.
#' @param annotation A list of 2-column data frames with columns
#' \strong{Gene} (gene ID) and \strong{Annotation} (annotation ID).
#' The names of list elements must correspond to species names as
#' in the second column of \emph{orthogroups}. For instance, if there are
#' two species in the \emph{orthogroups} data frame named
#' "SpeciesA" and "SpeciesB", \emph{annotation} must be a
#' list of 2 data frames, and each list element must be named
#' "SpeciesA" and "SpeciesB".
#' @param correct_overclustering Logical indicating whether to correct
#' for overclustering in orthogroups. Default: TRUE.
#' @param weight_homogeneity Numeric indicating the weight to which homogeneity
#' scores will be multiplied. Only valid
#' if \strong{correct_overclustering = TRUE}. Default: 1.
#' @param weight_dispersal Numeric indicating the weight to which dispersal
#' scores will be multiplied. Only valid
#' if \strong{correct_overclustering = TRUE}. Default: 1.
#' @param scale Logical indicating whether or not to scale scores by the
#' maximum value. Only valid if \strong{correct_overclustering = TRUE}.
#' Default: TRUE.
#'
#' @return A data frame.
#' @rdname assess_orthogroups
#' @export
#' @examples
#' data(og)
#' data(interpro_ath)
#' data(interpro_bol)
#' # Subsetting annotation for demonstration purposes.
#' annotation <- list(Ath = interpro_ath[1:1000,], Bol = interpro_bol[1:1000,])
#' assess <- assess_orthogroups(og, annotation)
assess_orthogroups <- function(orthogroups = NULL, annotation = NULL,
                               correct_overclustering = TRUE,
                               weight_homogeneity = 1, weight_dispersal = 1,
                               scale = TRUE) {

    og_list <- split(orthogroups, orthogroups$Species)
    og_list <- lapply(seq_along(og_list), function(x) {
        species <- names(og_list)[x]
        idx <- which(names(annotation) == species)
        merged <- merge(og_list[[x]], annotation[[idx]])
        names(merged)[4] <- "Annotation"
        H <- calculate_H(
            merged,
            correct_overclustering = correct_overclustering,
            weight_homogeneity = weight_homogeneity,
            weight_dispersal = weight_dispersal,
            scale = scale
        )
        names(H) <- c("Orthogroups", paste0(species, "_score"))
        return(H)
    })

    merge_func <- function(x, y) {
        merge(x, y, by = "Orthogroups", all = TRUE)
    }
    final_df <- Reduce(merge_func, og_list)
    means <- apply(final_df[, -1], 1, mean, na.rm = TRUE)
    final_df$Mean_score <- means
    return(final_df)
}


#' Compare inferred orthogroups to a references set
#'
#' @param ref_orthogroups Reference orthogroups in a 3-column data frame
#' with columns \strong{Orthogroup}, \strong{Species}, and \strong{Gene}.
#' This data frame can be created from the 'Orthogroups.tsv' file
#' generated by OrthoFinder with the function \code{read_orthogroups()}.
#' @param test_orthogroups Test orthogroups that will be compared
#' to \emph{ref_orthogroups} in the same 3-column data frame format.
#'
#' @details This function compares a test set of orthogroups to a reference set
#' and returns which orthogroups in the reference set are fully preserved
#' in the test set (i.e., identical gene repertoire) and which are not.
#'
#' @return A 2-column data frame with the following variables:
#' \describe{
#'   \item{Orthogroup}{Character of orthogroup IDs.}
#'   \item{Preserved}{A logical vector of preservation status. It is TRUE if
#'   the orthogroup in the reference set is fully preserved in the test set,
#'   and FALSE otherwise.}
#' }
#' @export
#' @rdname compare_orthogroups
#' @examples
#' set.seed(123)
#' data(og)
#' og <- og[1:5000, ]
#' ref <- og
#' # Shuffle genes to simulate a different set
#' test <- data.frame(Orthogroup = sample(og$Orthogroup, nrow(og),
#'                                        replace=FALSE),
#'                    Species = og$Species,
#'                    Gene = og$Gene)
#' comparison <- compare_orthogroups(ref, test)
#' # Calculating percentage of preservation
#' sum(comparison$Preserved) / length(comparison$Preserved)
compare_orthogroups <- function(ref_orthogroups = NULL,
                                test_orthogroups = NULL) {

    test_ortho <- test_orthogroups
    ref_list <- split(ref_orthogroups, ref_orthogroups$Orthogroup)
    comp <- Reduce(rbind, lapply(ref_list, function(x) {
        genes_ref <- x$Gene
        og_test <- test_ortho[test_ortho$Gene %in% genes_ref, "Orthogroup"]
        og_test <- unique(og_test)
        n_ogs <- length(og_test)
        preserved <- FALSE
        if(n_ogs == 1) {
            genes_test <- test_ortho[test_ortho$Orthogroup %in% og_test, "Gene"]
            if(length(genes_test) == length(genes_ref)) {
                preserved <- TRUE
            }
        }
        df <- data.frame(Orthogroup = unique(x$Orthogroup),
                         Preserved = preserved)
        return(df)
    }))
    return(comp)
}

